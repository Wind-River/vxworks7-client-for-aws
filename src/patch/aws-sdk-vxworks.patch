diff --git a/external_libs/jsmn/Makefile b/external_libs/jsmn/Makefile
new file mode 100644
index 0000000..5220eb8
--- /dev/null
+++ b/external_libs/jsmn/Makefile
@@ -0,0 +1,57 @@
+# Copyright (c) 2016, Wind River Systems, Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification, are
+# permitted provided that the following conditions are met:
+#
+# 1) Redistributions of source code must retain the above copyright notice,
+# this list of conditions and the following disclaimer.
+#
+# 2) Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation and/or
+# other materials provided with the distribution.
+#
+# 3) Neither the name of Wind River Systems nor the names of its contributors may be
+# used to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+LIB_BASE_NAME = aws
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/defs.library.mk
+else
+include $(WIND_KRNL_MK)/defs.library.mk
+endif
+
+DOC_FILES =
+
+OBJS = jsmn.o
+
+ifeq ($(TOOL_FAMILY), diab)
+CC_OPTIM += -Xdialect-c99
+endif
+
+ifeq ($(TOOL_FAMILY), gnu)
+CC_OPTIM += -std=c99
+endif
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/rules.library.mk
+else
+include $(WIND_KRNL_MK)/rules.library.mk
+endif
+
+#
+# this code is 3rd party. Suppress all compiler warnings
+#
+CC_WARNINGS = $(CC_WARNINGS_NONE)
diff --git a/external_libs/mbedTLS/include/mbedtls/config.h b/external_libs/mbedTLS/include/mbedtls/config.h
index 6e9d8f3..226063f 100644
--- a/external_libs/mbedTLS/include/mbedtls/config.h
+++ b/external_libs/mbedTLS/include/mbedtls/config.h
@@ -750,7 +750,7 @@
  *
  * Uncomment this macro to prevent loading of default entropy functions.
  */
-//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
+#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 
 /**
  * \def MBEDTLS_NO_PLATFORM_ENTROPY
@@ -761,7 +761,7 @@
  *
  * Uncomment this macro to disable the built-in platform entropy functions.
  */
-//#define MBEDTLS_NO_PLATFORM_ENTROPY
+#define MBEDTLS_NO_PLATFORM_ENTROPY
 
 /**
  * \def MBEDTLS_ENTROPY_FORCE_SHA256
diff --git a/external_libs/mbedTLS/include/mbedtls/entropy_poll.h b/external_libs/mbedTLS/include/mbedtls/entropy_poll.h
index dc11911..959bee6 100644
--- a/external_libs/mbedTLS/include/mbedtls/entropy_poll.h
+++ b/external_libs/mbedTLS/include/mbedtls/entropy_poll.h
@@ -82,6 +82,20 @@ int mbedtls_hardware_poll( void *data,
                            unsigned char *output, size_t len, size_t *olen );
 #endif
 
+#if defined(__VXWORKS__)
+/**
+ * \brief           VxWorks entropy build function
+ */
+
+void mbedtls_vxworks_entropy_build (void);
+
+/**
+ * \brief           VxWorks entropy poll callback
+ */
+int mbedtls_vxworks_poll( void *data,
+                    unsigned char *output, size_t len, size_t *olen );
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/external_libs/mbedTLS/library/Makefile b/external_libs/mbedTLS/library/Makefile
index f72ae8e..e81d9e0 100644
--- a/external_libs/mbedTLS/library/Makefile
+++ b/external_libs/mbedTLS/library/Makefile
@@ -1,167 +1,84 @@
-
-# Also see "include/mbedtls/config.h"
-
-CFLAGS	?= -O2
-WARNING_CFLAGS ?=  -Wall -W -Wdeclaration-after-statement
-LDFLAGS ?=
-
-LOCAL_CFLAGS = $(WARNING_CFLAGS) -I../include -D_FILE_OFFSET_BITS=64
-LOCAL_LDFLAGS =
-
-ifdef DEBUG
-LOCAL_CFLAGS += -g3
-endif
-
-# MicroBlaze specific options:
-# CFLAGS += -mno-xl-soft-mul -mxl-barrel-shift
-
-# To compile on Plan9:
-# CFLAGS += -D_BSD_EXTENSION
-
-# if were running on Windows build for Windows
-ifdef WINDOWS
-WINDOWS_BUILD=1
-endif
-
-# To compile as a shared library:
-ifdef SHARED
-# all code is position-indep with mingw, avoid warning about useless flag
-ifndef WINDOWS_BUILD
-LOCAL_CFLAGS += -fPIC -fpic
-endif
+# Copyright (c) 2016, Wind River Systems, Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification, are
+# permitted provided that the following conditions are met:
+#
+# 1) Redistributions of source code must retain the above copyright notice,
+# this list of conditions and the following disclaimer.
+#
+# 2) Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation and/or
+# other materials provided with the distribution.
+#
+# 3) Neither the name of Wind River Systems nor the names of its contributors may be
+# used to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+LIB_BASE_NAME = aws
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/defs.library.mk
+else
+include $(WIND_KRNL_MK)/defs.library.mk
 endif
 
-SOEXT_TLS=so.10
-SOEXT_X509=so.0
-SOEXT_CRYPTO=so.0
+DOC_FILES =
 
-DLEXT=so
-# OSX shared library extension:
-# DLEXT=dylib
-
-# Windows shared library extension:
-ifdef WINDOWS_BUILD
-DLEXT=dll
-endif
-
-OBJS_CRYPTO=	aes.o		aesni.o		arc4.o		\
-		asn1parse.o	asn1write.o	base64.o	\
-		bignum.o	blowfish.o	camellia.o	\
-		ccm.o		cipher.o	cipher_wrap.o	\
-		ctr_drbg.o	des.o		dhm.o		\
-		ecdh.o		ecdsa.o		ecp.o		\
+OBJS =	aes.o		aesni.o		arc4.o				\
+		asn1parse.o	asn1write.o	base64.o			\
+		bignum.o	blowfish.o	camellia.o			\
+		ccm.o		cipher.o	cipher_wrap.o		\
+		ctr_drbg.o	des.o		dhm.o				\
+		ecdh.o		ecdsa.o		ecp.o				\
 		ecp_curves.o	entropy.o	entropy_poll.o	\
-		error.o		gcm.o		havege.o	\
-		hmac_drbg.o	md.o		md2.o		\
-		md4.o		md5.o		md_wrap.o	\
-		memory_buffer_alloc.o		oid.o		\
-		padlock.o	pem.o		pk.o		\
-		pk_wrap.o	pkcs12.o	pkcs5.o		\
-		pkparse.o	pkwrite.o	platform.o	\
-		ripemd160.o	rsa.o		sha1.o		\
-		sha256.o	sha512.o	threading.o	\
-		timing.o	version.o			\
+		error.o		gcm.o		havege.o			\
+		hmac_drbg.o	md.o		md2.o				\
+		md4.o		md5.o		md_wrap.o			\
+		memory_buffer_alloc.o		oid.o			\
+		padlock.o	pem.o		pk.o				\
+		pk_wrap.o	pkcs12.o	pkcs5.o				\
+		pkparse.o	pkwrite.o	platform.o			\
+		ripemd160.o	rsa.o		sha1.o				\
+		sha256.o	sha512.o	threading.o			\
+		timing.o	version.o						\
 		version_features.o		xtea.o
 
-OBJS_X509=	certs.o		pkcs11.o	x509.o		\
-		x509_create.o	x509_crl.o	x509_crt.o	\
+OBJS +=	certs.o		pkcs11.o	x509.o				\
+		x509_create.o	x509_crl.o	x509_crt.o		\
 		x509_csr.o	x509write_crt.o	x509write_csr.o
 
-OBJS_TLS=	debug.o		net.o		ssl_cache.o	\
-		ssl_ciphersuites.o		ssl_cli.o	\
+OBJS +=	debug.o		net.o		ssl_cache.o			\
+		ssl_ciphersuites.o		ssl_cli.o			\
 		ssl_cookie.o	ssl_srv.o	ssl_ticket.o	\
 		ssl_tls.o
 
-.SILENT:
+ifeq ($(TOOL_FAMILY), diab)
+CC_OPTIM += -Xdialect-c99
+endif
 
-.PHONY: all static shared clean
+ifeq ($(TOOL_FAMILY), gnu)
+CC_OPTIM += -std=c99
+endif
 
-ifndef SHARED
-all: static
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/rules.library.mk
 else
-all: shared static
+include $(WIND_KRNL_MK)/rules.library.mk
 endif
 
-static: libmbedcrypto.a libmbedx509.a libmbedtls.a
-
-shared: libmbedcrypto.$(DLEXT) libmbedx509.$(DLEXT) libmbedtls.$(DLEXT)
+#
+# this code is 3rd party. Suppress all compiler warnings
+#
+CC_WARNINGS = $(CC_WARNINGS_NONE)
 
-# tls
-libmbedtls.a: $(OBJS_TLS)
-	echo "  AR    $@"
-	$(AR) rc $@ $(OBJS_TLS)
-	echo "  RL    $@"
-	$(AR) s $@
-
-libmbedtls.$(SOEXT_TLS): $(OBJS_TLS) libmbedx509.so
-	echo "  LD    $@"
-	$(CC) -shared -Wl,-soname,$@ -L. -lmbedcrypto -lmbedx509 $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_TLS)
-
-libmbedtls.so: libmbedtls.$(SOEXT_TLS)
-	echo "  LN    $@ -> $<"
-	ln -sf $< $@
-
-libmbedtls.dylib: $(OBJS_TLS)
-	echo "  LD    $@"
-	$(CC) -dynamiclib $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_TLS)
-
-libmbedtls.dll: $(OBJS_TLS) libmbedx509.dll
-	echo "  LD    $@"
-	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_TLS) -lws2_32 -lwinmm -lgdi32 -L. -lmbedcrypto -lmbedx509 -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
-
-# x509
-libmbedx509.a: $(OBJS_X509)
-	echo "  AR    $@"
-	$(AR) rc $@ $(OBJS_X509)
-	echo "  RL    $@"
-	$(AR) s $@
-
-libmbedx509.$(SOEXT_X509): $(OBJS_X509) libmbedcrypto.so
-	echo "  LD    $@"
-	$(CC) -shared -Wl,-soname,$@ -L. -lmbedcrypto $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_X509)
-
-libmbedx509.so: libmbedx509.$(SOEXT_X509)
-	echo "  LN    $@ -> $<"
-	ln -sf $< $@
-
-libmbedx509.dylib: $(OBJS_X509)
-	echo "  LD    $@"
-	$(CC) -dynamiclib $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_X509)
-
-libmbedx509.dll: $(OBJS_X509) libmbedcrypto.dll
-	echo "  LD    $@"
-	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_X509) -lws2_32 -lwinmm -lgdi32 -L. -lmbedcrypto -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
-
-# crypto
-libmbedcrypto.a: $(OBJS_CRYPTO)
-	echo "  AR    $@"
-	$(AR) rc $@ $(OBJS_CRYPTO)
-	echo "  RL    $@"
-	$(AR) s $@
-
-libmbedcrypto.$(SOEXT_CRYPTO): $(OBJS_CRYPTO)
-	echo "  LD    $@"
-	$(CC) -shared -Wl,-soname,$@ $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_CRYPTO)
-
-libmbedcrypto.so: libmbedcrypto.$(SOEXT_CRYPTO)
-	echo "  LN    $@ -> $<"
-	ln -sf $< $@
-
-libmbedcrypto.dylib: $(OBJS_CRYPTO)
-	echo "  LD    $@"
-	$(CC) -dynamiclib $(LOCAL_LDFLAGS) $(LDFLAGS) -o $@ $(OBJS_CRYPTO)
-
-libmbedcrypto.dll: $(OBJS_CRYPTO)
-	echo "  LD    $@"
-	$(CC) -shared -Wl,-soname,$@ -Wl,--out-implib,$@.a -o $@ $(OBJS_CRYPTO) -lws2_32 -lwinmm -lgdi32 -static-libgcc $(LOCAL_LDFLAGS) $(LDFLAGS)
-
-.c.o:
-	echo "  CC    $<"
-	$(CC) $(LOCAL_CFLAGS) $(CFLAGS) -c $<
-
-clean:
-ifndef WINDOWS
-	rm -f *.o libmbed*
-else
-	del /Q /F *.o libmbed*
-endif
diff --git a/external_libs/mbedTLS/library/entropy.c b/external_libs/mbedTLS/library/entropy.c
index cdbd35c..c5b63d8 100644
--- a/external_libs/mbedTLS/library/entropy.c
+++ b/external_libs/mbedTLS/library/entropy.c
@@ -95,6 +95,14 @@ void mbedtls_entropy_init( mbedtls_entropy_context *ctx )
                                 MBEDTLS_ENTROPY_SOURCE_STRONG );
 #endif
 #endif /* MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES */
+
+#if defined(__VXWORKS__)
+    mbedtls_entropy_add_source( ctx, mbedtls_vxworks_poll, NULL,
+                                MBEDTLS_ENTROPY_MIN_PLATFORM,
+                                MBEDTLS_ENTROPY_SOURCE_STRONG );
+
+    mbedtls_vxworks_entropy_build();
+#endif /* __VXWORKS__ */
 }
 
 void mbedtls_entropy_free( mbedtls_entropy_context *ctx )
diff --git a/external_libs/mbedTLS/library/entropy_poll.c b/external_libs/mbedTLS/library/entropy_poll.c
index 25a27be..ff22e3f 100644
--- a/external_libs/mbedTLS/library/entropy_poll.c
+++ b/external_libs/mbedTLS/library/entropy_poll.c
@@ -25,6 +25,11 @@
 #include MBEDTLS_CONFIG_FILE
 #endif
 
+#if defined(__VXWORKS__)
+#include <vxWorks.h>
+#include <randomNumGen.h>
+#endif
+
 #if defined(MBEDTLS_ENTROPY_C)
 
 #include "mbedtls/entropy.h"
@@ -213,4 +218,39 @@ int mbedtls_havege_poll( void *data,
 }
 #endif /* MBEDTLS_HAVEGE_C */
 
+#if defined(__VXWORKS__)
+void mbedtls_vxworks_entropy_build (void)
+{
+    unsigned char seed[1024];
+    unsigned int i;
+
+    for ( i = 0; i < sizeof(seed); i++)
+    {
+        seed[i]= i*3%256;
+    }
+
+    /* build entropy */
+    randAdd( seed, 0, 0 );
+
+    /* build entropy */
+    for ( i = 4; i <= sizeof(seed); i *= 2)
+    {
+    randAdd ( seed, i - 1, i );
+    }
+}
+
+int mbedtls_vxworks_poll( void *data,
+                    unsigned char *output, size_t len, size_t *olen )
+{
+    ((void) data);
+
+    if( randBytes( output, len ) != OK)
+        return( -1 );
+
+    *olen = len;
+
+    return( 0 );
+}
+#endif /* __VXWORKS__ */
+
 #endif /* MBEDTLS_ENTROPY_C */
diff --git a/external_libs/mbedTLS/library/net.c b/external_libs/mbedTLS/library/net.c
index b5d0688..e9f40ff 100644
--- a/external_libs/mbedTLS/library/net.c
+++ b/external_libs/mbedTLS/library/net.c
@@ -70,7 +70,9 @@ static int wsa_init_done = 0;
 #include <fcntl.h>
 #include <netdb.h>
 #include <errno.h>
-
+#if defined(__VXWORKS__)
+#include <ioLib.h>
+#endif /* __VXWORKS__ */
 #endif /* ( _WIN32 || _WIN32_WCE ) && !EFIX64 && !EFI32 */
 
 /* Some MS functions want int and MSVC warns if we pass size_t,
@@ -407,8 +409,13 @@ int mbedtls_net_set_block( mbedtls_net_context *ctx )
     u_long n = 0;
     return( ioctlsocket( ctx->fd, FIONBIO, &n ) );
 #else
+#if defined(__VXWORKS__)
+    u_long n = 0;
+    return( ioctl( ctx->fd, FIONBIO, &n ) );
+#else
     return( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL ) & ~O_NONBLOCK ) );
 #endif
+#endif
 }
 
 int mbedtls_net_set_nonblock( mbedtls_net_context *ctx )
@@ -418,8 +425,13 @@ int mbedtls_net_set_nonblock( mbedtls_net_context *ctx )
     u_long n = 1;
     return( ioctlsocket( ctx->fd, FIONBIO, &n ) );
 #else
+#if defined(__VXWORKS__)
+    u_long n = 1;
+    return( ioctl( ctx->fd, FIONBIO, &n ) );
+#else
     return( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL ) | O_NONBLOCK ) );
 #endif
+#endif
 }
 
 /*
diff --git a/include/aws_iot_log.h b/include/aws_iot_log.h
index aec761c..99807f3 100644
--- a/include/aws_iot_log.h
+++ b/include/aws_iot_log.h
@@ -40,6 +40,7 @@ extern "C" {
  *
  * Macro to expose function, line number as well as desired log message.
  */
+
 #ifdef ENABLE_IOT_DEBUG
 #define IOT_DEBUG(...)    \
 	{\
@@ -56,6 +57,7 @@ extern "C" {
  *
  * Macro to print message function entry and exit
  */
+
 #ifdef ENABLE_IOT_TRACE
 #define FUNC_ENTRY    \
 	{\
@@ -82,6 +84,7 @@ extern "C" {
  *
  * Macro to expose desired log message.  Info messages do not include automatic function names and line numbers.
  */
+#define ENABLE_IOT_INFO
 #ifdef ENABLE_IOT_INFO
 #define IOT_INFO(...)    \
 	{\
@@ -97,6 +100,7 @@ extern "C" {
  *
  * Macro to expose function, line number as well as desired log message.
  */
+
 #ifdef ENABLE_IOT_WARN
 #define IOT_WARN(...)   \
 	{ \
@@ -113,6 +117,7 @@ extern "C" {
  *
  * Macro to expose function, line number as well as desired log message.
  */
+
 #ifdef ENABLE_IOT_ERROR
 #define IOT_ERROR(...)  \
 	{ \
diff --git a/platform/vxworks/common/Makefile b/platform/vxworks/common/Makefile
new file mode 100644
index 0000000..874d992
--- /dev/null
+++ b/platform/vxworks/common/Makefile
@@ -0,0 +1,59 @@
+# Copyright (c) 2016, Wind River Systems, Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification, are
+# permitted provided that the following conditions are met:
+#
+# 1) Redistributions of source code must retain the above copyright notice,
+# this list of conditions and the following disclaimer.
+#
+# 2) Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation and/or
+# other materials provided with the distribution.
+#
+# 3) Neither the name of Wind River Systems nor the names of its contributors may be
+# used to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+LIB_BASE_NAME = aws
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/defs.library.mk
+else
+include $(WIND_KRNL_MK)/defs.library.mk
+endif
+
+DOC_FILES =
+
+EXTRA_DEFINE += -Dinit_timer=init_timer_wr
+
+OBJS = timer.o
+
+ifeq ($(TOOL_FAMILY), diab)
+CC_OPTIM += -Xdialect-c99
+endif
+
+ifeq ($(TOOL_FAMILY), gnu)
+CC_OPTIM += -std=c99
+endif
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/rules.library.mk
+else
+include $(WIND_KRNL_MK)/rules.library.mk
+endif
+
+#
+# this code is 3rd party. Suppress all compiler warnings
+#
+CC_WARNINGS = $(CC_WARNINGS_NONE)
diff --git a/platform/vxworks/common/timer.c b/platform/vxworks/common/timer.c
new file mode 100644
index 0000000..fcf2446
--- /dev/null
+++ b/platform/vxworks/common/timer.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file timer.c
+ * @brief VxWorks implementation of the timer interface.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "timer_platform.h"
+
+#define timeradd(a, b, result)                              \
+    do {                                                    \
+        (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;       \
+        (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;    \
+        if ((result)->tv_usec >= 1000000)                   \
+            {                                               \
+            ++(result)->tv_sec;                             \
+            (result)->tv_usec -= 1000000;                   \
+            }                                               \
+        } while (0)
+
+#define timersub(a, b, result)                              \
+    do {                                                    \
+        (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;       \
+        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;    \
+        if ((result)->tv_usec < 0)                          \
+            {                                               \
+            --(result)->tv_sec;                             \
+            (result)->tv_usec += 1000000;                   \
+            }                                               \
+        } while (0)
+
+bool has_timer_expired(Timer *timer) {
+	struct timeval now, res;
+	gettimeofday(&now, NULL);
+	timersub(&timer->end_time, &now, &res);
+	return res.tv_sec < 0 || (res.tv_sec == 0 && res.tv_usec <= 0);
+}
+
+void countdown_ms(Timer *timer, uint32_t timeout) {
+	struct timeval now;
+	gettimeofday(&now, NULL);
+#ifdef __cplusplus
+	struct timeval interval = {timeout / 1000, static_cast<int>((timeout % 1000) * 1000)};
+#else
+	struct timeval interval = {timeout / 1000, (int)((timeout % 1000) * 1000)};
+#endif
+	timeradd(&now, &interval, &timer->end_time);
+}
+
+uint32_t left_ms(Timer *timer) {
+	struct timeval now, res;
+	gettimeofday(&now, NULL);
+	timersub(&timer->end_time, &now, &res);
+	uint32_t result_ms = 0;
+	if(res.tv_sec >= 0) {
+		result_ms = (uint32_t) (res.tv_sec * 1000 + res.tv_usec / 1000);
+	}
+	return result_ms;
+}
+
+void countdown_sec(Timer *timer, uint32_t timeout) {
+	struct timeval now;
+	gettimeofday(&now, NULL);
+	struct timeval interval = {timeout, 0};
+	timeradd(&now, &interval, &timer->end_time);
+}
+
+void init_timer(Timer *timer) {
+	timer->end_time.tv_sec = 0;
+	timer->end_time.tv_usec = 0;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/platform/vxworks/common/timer_platform.h b/platform/vxworks/common/timer_platform.h
new file mode 100644
index 0000000..757483d
--- /dev/null
+++ b/platform/vxworks/common/timer_platform.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef SRC_PROTOCOL_MQTT_AWS_IOT_EMBEDDED_CLIENT_WRAPPER_PLATFORM_LINUX_COMMON_TIMER_PLATFORM_H_
+#define SRC_PROTOCOL_MQTT_AWS_IOT_EMBEDDED_CLIENT_WRAPPER_PLATFORM_LINUX_COMMON_TIMER_PLATFORM_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file timer_platform.h
+ */
+#include <sys/time.h>
+//#include <sys/select.h>
+#include "timer_interface.h"
+
+/**
+ * definition of the Timer struct. Platform specific
+ */
+struct Timer {
+	struct timeval end_time;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SRC_PROTOCOL_MQTT_AWS_IOT_EMBEDDED_CLIENT_WRAPPER_PLATFORM_LINUX_COMMON_TIMER_PLATFORM_H_ */
diff --git a/platform/vxworks/libc/inttypes.h b/platform/vxworks/libc/inttypes.h
new file mode 100644
index 0000000..8aeda78
--- /dev/null
+++ b/platform/vxworks/libc/inttypes.h
@@ -0,0 +1,246 @@
+/* inttypes.h standard header */
+
+/* Copyright (c) 2016, Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors may be
+ * used to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _INTTYPES
+#define _INTTYPES
+#include <stdint.h>
+
+ #if _INTPTR == 0
+  #define _PFX_PTR	""
+
+ #elif _INTPTR == 1
+  #define _PFX_PTR	"l"
+
+ #else /* _INTPTR */
+  #define _PFX_PTR	"ll"
+ #endif /* _INTPTR */
+
+#define _PFX_8		"hh"
+ #define _PFX_16	"h"
+ #define _PFX_64	"ll"
+
+ #if _ILONG
+  #define _PFX_32	""
+
+ #else /* _LLONG */
+  #define _PFX_32	"l"
+ #endif /* _LLONG */
+
+ #ifdef _FAST16_IS_32	/* compiler test */
+  #define _PFX_F16	_PFX_32
+
+ #else /* _FAST16_IS_32	*/
+  #define _PFX_F16	_PFX_16
+ #endif /* _FAST16_IS_32	*/
+
+		/* PRINT FORMAT MACROS */
+ #define PRId8			_PFX_8 "d"
+ #define PRId16			_PFX_16 "d"
+ #define PRId32			_PFX_32 "d"
+ #define PRIdLEAST8		_PFX_8 "d"
+ #define PRIdLEAST16	_PFX_16 "d"
+ #define PRIdLEAST32	_PFX_32 "d"
+ #define PRIdFAST8		_PFX_8 "d"
+ #define PRIdFAST16		_PFX_F16 "d"
+ #define PRIdFAST32		_PFX_32 "d"
+
+ #define PRIi8			_PFX_8 "i"
+ #define PRIi16			_PFX_16 "i"
+ #define PRIi32			_PFX_32 "i"
+ #define PRIiLEAST8		_PFX_8 "i"
+ #define PRIiLEAST16	_PFX_16 "i"
+ #define PRIiLEAST32	_PFX_32 "i"
+ #define PRIiFAST8		_PFX_8 "i"
+ #define PRIiFAST16		_PFX_F16 "i"
+ #define PRIiFAST32		_PFX_32 "i"
+
+ #define PRIo8			_PFX_8 "o"
+ #define PRIo16			_PFX_16 "o"
+ #define PRIo32			_PFX_32 "o"
+ #define PRIoLEAST8		_PFX_8 "o"
+ #define PRIoLEAST16	_PFX_16 "o"
+ #define PRIoLEAST32	_PFX_32 "o"
+ #define PRIoFAST8		_PFX_8 "o"
+ #define PRIoFAST16		_PFX_F16 "o"
+ #define PRIoFAST32		_PFX_32 "o"
+
+ #define PRIu8			_PFX_8 "u"
+ #define PRIu16			_PFX_16 "u"
+ #define PRIu32			_PFX_32 "u"
+ #define PRIuLEAST8		_PFX_8 "u"
+ #define PRIuLEAST16	_PFX_16 "u"
+ #define PRIuLEAST32	_PFX_32 "u"
+ #define PRIuFAST8		_PFX_8 "u"
+ #define PRIuFAST16		_PFX_F16 "u"
+ #define PRIuFAST32		_PFX_32 "u"
+
+ #define PRIx8			_PFX_8 "x"
+ #define PRIx16			_PFX_16 "x"
+ #define PRIx32			_PFX_32 "x"
+ #define PRIxLEAST8		_PFX_8 "x"
+ #define PRIxLEAST16	_PFX_16 "x"
+ #define PRIxLEAST32	_PFX_32 "x"
+ #define PRIxFAST8		_PFX_8 "x"
+ #define PRIxFAST16		_PFX_F16 "x"
+ #define PRIxFAST32		_PFX_32 "x"
+
+ #define PRIX8			_PFX_8 "X"
+ #define PRIX16			_PFX_16 "X"
+ #define PRIX32			_PFX_32 "X"
+ #define PRIXLEAST8		_PFX_8 "X"
+ #define PRIXLEAST16	_PFX_16 "X"
+ #define PRIXLEAST32	_PFX_32 "X"
+ #define PRIXFAST8		_PFX_8 "X"
+ #define PRIXFAST16		_PFX_F16 "X"
+ #define PRIXFAST32		_PFX_32 "X"
+
+ #define PRId64			_PFX_64 "d"
+ #define PRIdLEAST64	_PFX_64 "d"
+ #define PRIdFAST64		_PFX_64 "d"
+ #define PRIdMAX		_PFX_64 "d"
+ #define PRIdPTR		_PFX_PTR "d"
+
+ #define PRIi64			_PFX_64 "i"
+ #define PRIiLEAST64	_PFX_64 "i"
+ #define PRIiFAST64		_PFX_64 "i"
+ #define PRIiMAX		_PFX_64 "i"
+ #define PRIiPTR		_PFX_PTR "i"
+
+ #define PRIo64			_PFX_64 "o"
+ #define PRIoLEAST64	_PFX_64 "o"
+ #define PRIoFAST64		_PFX_64 "o"
+ #define PRIoMAX		_PFX_64 "o"
+ #define PRIoPTR		_PFX_PTR "o"
+
+ #define PRIu64			_PFX_64 "u"
+ #define PRIuLEAST64	_PFX_64 "u"
+ #define PRIuFAST64		_PFX_64 "u"
+ #define PRIuMAX		_PFX_64 "u"
+ #define PRIuPTR		_PFX_PTR "u"
+
+ #define PRIx64			_PFX_64 "x"
+ #define PRIxLEAST64	_PFX_64 "x"
+ #define PRIxFAST64		_PFX_64 "x"
+ #define PRIxMAX		_PFX_64 "x"
+ #define PRIxPTR		_PFX_PTR "x"
+
+ #define PRIX64			_PFX_64 "X"
+ #define PRIXLEAST64	_PFX_64 "X"
+ #define PRIXFAST64		_PFX_64 "X"
+ #define PRIXMAX		_PFX_64 "X"
+ #define PRIXPTR		_PFX_PTR "X"
+
+		/* SCAN FORMAT MACROS */
+ #define SCNd8			_PFX_8 "d"
+ #define SCNd16			_PFX_16 "d"
+ #define SCNd32			_PFX_32 "d"
+ #define SCNdLEAST8		_PFX_8 "d"
+ #define SCNdLEAST16	_PFX_16 "d"
+ #define SCNdLEAST32	_PFX_32 "d"
+ #define SCNdFAST8		_PFX_8 "d"
+ #define SCNdFAST16		_PFX_F16 "d"
+ #define SCNdFAST32		_PFX_32 "d"
+
+ #define SCNi8			_PFX_8 "i"
+ #define SCNi16			_PFX_16 "i"
+ #define SCNi32			_PFX_32 "i"
+ #define SCNiLEAST8		_PFX_8 "i"
+ #define SCNiLEAST16	_PFX_16 "i"
+ #define SCNiLEAST32	_PFX_32 "i"
+ #define SCNiFAST8		_PFX_8 "i"
+ #define SCNiFAST16		_PFX_F16 "i"
+ #define SCNiFAST32		_PFX_32 "i"
+
+ #define SCNo8			_PFX_8 "o"
+ #define SCNo16			_PFX_16 "o"
+ #define SCNo32			_PFX_32 "o"
+ #define SCNoLEAST8		_PFX_8 "o"
+ #define SCNoLEAST16	_PFX_16 "o"
+ #define SCNoLEAST32	_PFX_32 "o"
+ #define SCNoFAST8		_PFX_8 "o"
+ #define SCNoFAST16		_PFX_F16 "o"
+ #define SCNoFAST32		_PFX_32 "o"
+
+ #define SCNu8			_PFX_8 "u"
+ #define SCNu16			_PFX_16 "u"
+ #define SCNu32			_PFX_32 "u"
+ #define SCNuLEAST8		_PFX_8 "u"
+ #define SCNuLEAST16	_PFX_16 "u"
+ #define SCNuLEAST32	_PFX_32 "u"
+ #define SCNuFAST8		_PFX_8 "u"
+ #define SCNuFAST16		_PFX_F16 "u"
+ #define SCNuFAST32		_PFX_32 "u"
+
+ #define SCNx8			_PFX_8 "x"
+ #define SCNx16			_PFX_16 "x"
+ #define SCNx32			_PFX_32 "x"
+ #define SCNxLEAST8		_PFX_8 "x"
+ #define SCNxLEAST16	_PFX_16 "x"
+ #define SCNxLEAST32	_PFX_32 "x"
+ #define SCNxFAST8		_PFX_8 "x"
+ #define SCNxFAST16		_PFX_F16 "x"
+ #define SCNxFAST32		_PFX_32 "x"
+
+ #define SCNd64			_PFX_64 "d"
+ #define SCNdLEAST64	_PFX_64 "d"
+ #define SCNdFAST64		_PFX_64 "d"
+ #define SCNdMAX		_PFX_64 "d"
+ #define SCNdPTR		_PFX_PTR "d"
+
+ #define SCNi64			_PFX_64 "i"
+ #define SCNiLEAST64	_PFX_64 "i"
+ #define SCNiFAST64		_PFX_64 "i"
+ #define SCNiMAX		_PFX_64 "i"
+ #define SCNiPTR		_PFX_PTR "i"
+
+ #define SCNo64			_PFX_64 "o"
+ #define SCNoLEAST64	_PFX_64 "o"
+ #define SCNoFAST64		_PFX_64 "o"
+ #define SCNoMAX		_PFX_64 "o"
+ #define SCNoPTR		_PFX_PTR "o"
+
+ #define SCNu64			_PFX_64 "u"
+ #define SCNuLEAST64	_PFX_64 "u"
+ #define SCNuFAST64		_PFX_64 "u"
+ #define SCNuMAX		_PFX_64 "u"
+ #define SCNuPTR		_PFX_PTR "u"
+
+ #define SCNx64			_PFX_64 "x"
+ #define SCNxLEAST64	_PFX_64 "x"
+ #define SCNxFAST64		_PFX_64 "x"
+ #define SCNxMAX		_PFX_64 "x"
+ #define SCNxPTR		_PFX_PTR "x"
+
+#endif /* _INTTYPES */
+
+/*
+ * Copyright (c) by P.J. Plauger. All rights reserved.
+ * Consult your license regarding permissions and restrictions.
+V6.50:1278 */
diff --git a/platform/vxworks/libc/stdbool.h b/platform/vxworks/libc/stdbool.h
new file mode 100644
index 0000000..2cccf86
--- /dev/null
+++ b/platform/vxworks/libc/stdbool.h
@@ -0,0 +1,56 @@
+/* stdbool.h - boolean type and values */
+
+/* Copyright (c) 2016, Wind River Systems, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are
+ * permitted provided that the following conditions are met:
+ *
+ * 1) Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2) Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation and/or
+ * other materials provided with the distribution.
+ *
+ * 3) Neither the name of Wind River Systems nor the names of its contributors may be
+ * used to endorse or promote products derived from this software without specific
+ * prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __INCstdboolh__
+#define __INCstdboolh__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __bool_true_false_are_defined 1
+
+#ifndef bool
+typedef unsigned int bool;
+#endif
+
+#ifndef true
+#define true 1
+#endif
+
+#ifndef false
+#define false 0
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/platform/vxworks/mbedtls/Makefile b/platform/vxworks/mbedtls/Makefile
new file mode 100644
index 0000000..a58b662
--- /dev/null
+++ b/platform/vxworks/mbedtls/Makefile
@@ -0,0 +1,59 @@
+# Copyright (c) 2016, Wind River Systems, Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification, are
+# permitted provided that the following conditions are met:
+#
+# 1) Redistributions of source code must retain the above copyright notice,
+# this list of conditions and the following disclaimer.
+#
+# 2) Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation and/or
+# other materials provided with the distribution.
+#
+# 3) Neither the name of Wind River Systems nor the names of its contributors may be
+# used to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+LIB_BASE_NAME = aws
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/defs.library.mk
+else
+include $(WIND_KRNL_MK)/defs.library.mk
+endif
+
+DOC_FILES =
+
+EXTRA_DEFINE += -Dinit_timer=init_timer_wr
+
+OBJS = network_mbedtls_wrapper.o
+
+ifeq ($(TOOL_FAMILY), diab)
+CC_OPTIM += -Xdialect-c99
+endif
+
+ifeq ($(TOOL_FAMILY), gnu)
+CC_OPTIM += -std=c99
+endif
+
+ifeq ($(SPACE), user)
+include $(WIND_USR_MK)/rules.library.mk
+else
+include $(WIND_KRNL_MK)/rules.library.mk
+endif
+
+#
+# this code is 3rd party. Suppress all compiler warnings
+#
+CC_WARNINGS = $(CC_WARNINGS_NONE)
diff --git a/platform/vxworks/mbedtls/network_mbedtls_wrapper.c b/platform/vxworks/mbedtls/network_mbedtls_wrapper.c
new file mode 100644
index 0000000..01f96e9
--- /dev/null
+++ b/platform/vxworks/mbedtls/network_mbedtls_wrapper.c
@@ -0,0 +1,376 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdbool.h>
+#include <string.h>
+#include <timer_platform.h>
+#include <network_interface.h>
+
+#include "aws_iot_error.h"
+#include "aws_iot_log.h"
+#include "network_interface.h"
+#include "network_platform.h"
+
+/* This is the value used for ssl read timeout */
+#define IOT_SSL_READ_TIMEOUT 10
+
+#if 1
+#define mbedtls_printf    printf
+
+static void my_debug( void *ctx, int level, const char *file, int line, const char *str )
+    {
+    ((void) level);
+
+    mbedtls_printf("%s:%04d: %s", file, line, str);
+    }
+#endif
+
+/*
+ * This is a function to do further verification if needed on the cert received
+ */
+
+static int _iot_tls_verify_cert(void *data, mbedtls_x509_crt *crt, int depth, uint32_t *flags) {
+	char buf[1024];
+	((void) data);
+
+	IOT_DEBUG("\nVerify requested for (Depth %d):\n", depth);
+	mbedtls_x509_crt_info(buf, sizeof(buf) - 1, "", crt);
+	IOT_DEBUG("%s", buf);
+
+	if((*flags) == 0) {
+		IOT_DEBUG("  This certificate has no flags\n");
+	} else {
+		IOT_DEBUG(buf, sizeof(buf), "  ! ", *flags);
+		IOT_DEBUG("%s\n", buf);
+	}
+
+	return 0;
+}
+
+void _iot_tls_set_connect_params(Network *pNetwork, char *pRootCALocation, char *pDeviceCertLocation,
+								 char *pDevicePrivateKeyLocation, char *pDestinationURL,
+								 uint16_t destinationPort, uint32_t timeout_ms, bool ServerVerificationFlag) {
+	pNetwork->tlsConnectParams.DestinationPort = destinationPort;
+	pNetwork->tlsConnectParams.pDestinationURL = pDestinationURL;
+	pNetwork->tlsConnectParams.pDeviceCertLocation = pDeviceCertLocation;
+	pNetwork->tlsConnectParams.pDevicePrivateKeyLocation = pDevicePrivateKeyLocation;
+	pNetwork->tlsConnectParams.pRootCALocation = pRootCALocation;
+	pNetwork->tlsConnectParams.timeout_ms = timeout_ms;
+	pNetwork->tlsConnectParams.ServerVerificationFlag = ServerVerificationFlag;
+}
+
+IoT_Error_t iot_tls_init(Network *pNetwork, char *pRootCALocation, char *pDeviceCertLocation,
+						 char *pDevicePrivateKeyLocation, char *pDestinationURL,
+						 uint16_t destinationPort, uint32_t timeout_ms, bool ServerVerificationFlag) {
+	_iot_tls_set_connect_params(pNetwork, pRootCALocation, pDeviceCertLocation, pDevicePrivateKeyLocation,
+								pDestinationURL, destinationPort, timeout_ms, ServerVerificationFlag);
+
+	pNetwork->connect = iot_tls_connect;
+	pNetwork->read = iot_tls_read;
+	pNetwork->write = iot_tls_write;
+	pNetwork->disconnect = iot_tls_disconnect;
+	pNetwork->isConnected = iot_tls_is_connected;
+	pNetwork->destroy = iot_tls_destroy;
+
+	pNetwork->tlsDataParams.flags = 0;
+
+	return SUCCESS;
+}
+
+IoT_Error_t iot_tls_is_connected(Network *pNetwork) {
+	/* Use this to add implementation which can check for physical layer disconnect */
+	return NETWORK_PHYSICAL_LAYER_CONNECTED;
+}
+
+IoT_Error_t iot_tls_connect(Network *pNetwork, TLSConnectParams *params) {
+	if(NULL == pNetwork) {
+		return NULL_VALUE_ERROR;
+	}
+
+	if(NULL != params) {
+		_iot_tls_set_connect_params(pNetwork, params->pRootCALocation, params->pDeviceCertLocation,
+									params->pDevicePrivateKeyLocation, params->pDestinationURL,
+									params->DestinationPort, params->timeout_ms, params->ServerVerificationFlag);
+	}
+
+	int ret = 0;
+	const char *pers = "aws_iot_tls_wrapper";
+#ifdef IOT_DEBUG
+	unsigned char buf[MBEDTLS_SSL_MAX_CONTENT_LEN + 1];
+#endif
+	TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);
+
+	mbedtls_net_init(&(tlsDataParams->server_fd));
+	mbedtls_ssl_init(&(tlsDataParams->ssl));
+	mbedtls_ssl_config_init(&(tlsDataParams->conf));
+mbedtls_ssl_conf_dbg(&(tlsDataParams->conf), my_debug, stdout);
+	mbedtls_ctr_drbg_init(&(tlsDataParams->ctr_drbg));
+	mbedtls_x509_crt_init(&(tlsDataParams->cacert));
+	mbedtls_x509_crt_init(&(tlsDataParams->clicert));
+	mbedtls_pk_init(&(tlsDataParams->pkey));
+
+	IOT_DEBUG("\n  . Seeding the random number generator...");
+	mbedtls_entropy_init(&(tlsDataParams->entropy));
+	if((ret = mbedtls_ctr_drbg_seed(&(tlsDataParams->ctr_drbg), mbedtls_entropy_func, &(tlsDataParams->entropy),
+									(const unsigned char *) pers, strlen(pers))) != 0) {
+		IOT_ERROR(" failed\n  ! mbedtls_ctr_drbg_seed returned -0x%x\n", -ret);
+		return NETWORK_MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED;
+	}
+
+	IOT_DEBUG("  . Loading the CA root certificate ...");
+	ret = mbedtls_x509_crt_parse_file(&(tlsDataParams->cacert), pNetwork->tlsConnectParams.pRootCALocation);
+	if(ret < 0) {
+		IOT_ERROR(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing root cert\n\n", -ret);
+		return NETWORK_X509_ROOT_CRT_PARSE_ERROR;
+	}
+	IOT_DEBUG(" ok (%d skipped)\n", ret);
+
+	IOT_DEBUG("  . Loading the client cert. and key...");
+	ret = mbedtls_x509_crt_parse_file(&(tlsDataParams->clicert), pNetwork->tlsConnectParams.pDeviceCertLocation);
+	if(ret != 0) {
+		IOT_ERROR(" failed\n  !  mbedtls_x509_crt_parse returned -0x%x while parsing device cert\n\n", -ret);
+		return NETWORK_X509_DEVICE_CRT_PARSE_ERROR;
+	}
+
+	ret = mbedtls_pk_parse_keyfile(&(tlsDataParams->pkey), pNetwork->tlsConnectParams.pDevicePrivateKeyLocation, "");
+	if(ret != 0) {
+		IOT_ERROR(" failed\n  !  mbedtls_pk_parse_key returned -0x%x while parsing private key\n\n", -ret);
+		IOT_DEBUG(" path : %s ", pNetwork->tlsConnectParams.pDevicePrivateKeyLocation);
+		return NETWORK_PK_PRIVATE_KEY_PARSE_ERROR;
+	}
+	IOT_DEBUG(" ok\n");
+	char portBuffer[6];
+	snprintf(portBuffer, 6, "%d", pNetwork->tlsConnectParams.DestinationPort);
+	IOT_DEBUG("  . Connecting to %s/%s...", pNetwork->tlsConnectParams.pDestinationURL, portBuffer);
+	if((ret = mbedtls_net_connect(&(tlsDataParams->server_fd), pNetwork->tlsConnectParams.pDestinationURL,
+								  portBuffer, MBEDTLS_NET_PROTO_TCP)) != 0) {
+		IOT_ERROR(" failed\n  ! mbedtls_net_connect returned -0x%x\n\n", -ret);
+		switch(ret) {
+			case MBEDTLS_ERR_NET_SOCKET_FAILED:
+				return NETWORK_ERR_NET_SOCKET_FAILED;
+			case MBEDTLS_ERR_NET_UNKNOWN_HOST:
+				return NETWORK_ERR_NET_UNKNOWN_HOST;
+			case MBEDTLS_ERR_NET_CONNECT_FAILED:
+			default:
+				return NETWORK_ERR_NET_CONNECT_FAILED;
+		};
+	}
+
+	ret = mbedtls_net_set_block(&(tlsDataParams->server_fd));
+	if(ret != 0) {
+		IOT_ERROR(" failed\n  ! net_set_(non)block() returned -0x%x\n\n", -ret);
+		return SSL_CONNECTION_ERROR;
+	} IOT_DEBUG(" ok\n");
+
+	IOT_DEBUG("  . Setting up the SSL/TLS structure...");
+	if((ret = mbedtls_ssl_config_defaults(&(tlsDataParams->conf), MBEDTLS_SSL_IS_CLIENT, MBEDTLS_SSL_TRANSPORT_STREAM,
+										  MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {
+		IOT_ERROR(" failed\n  ! mbedtls_ssl_config_defaults returned -0x%x\n\n", -ret);
+		return SSL_CONNECTION_ERROR;
+	}
+
+	mbedtls_ssl_conf_verify(&(tlsDataParams->conf), _iot_tls_verify_cert, NULL);
+	if(pNetwork->tlsConnectParams.ServerVerificationFlag == true) {
+		mbedtls_ssl_conf_authmode(&(tlsDataParams->conf), MBEDTLS_SSL_VERIFY_REQUIRED);
+	} else {
+		mbedtls_ssl_conf_authmode(&(tlsDataParams->conf), MBEDTLS_SSL_VERIFY_OPTIONAL);
+	}
+	mbedtls_ssl_conf_rng(&(tlsDataParams->conf), mbedtls_ctr_drbg_random, &(tlsDataParams->ctr_drbg));
+
+	mbedtls_ssl_conf_ca_chain(&(tlsDataParams->conf), &(tlsDataParams->cacert), NULL);
+	if((ret = mbedtls_ssl_conf_own_cert(&(tlsDataParams->conf), &(tlsDataParams->clicert), &(tlsDataParams->pkey))) !=
+	   0) {
+		IOT_ERROR(" failed\n  ! mbedtls_ssl_conf_own_cert returned %d\n\n", ret);
+		return SSL_CONNECTION_ERROR;
+	}
+
+	mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), pNetwork->tlsConnectParams.timeout_ms);
+
+	if((ret = mbedtls_ssl_setup(&(tlsDataParams->ssl), &(tlsDataParams->conf))) != 0) {
+		IOT_ERROR(" failed\n  ! mbedtls_ssl_setup returned -0x%x\n\n", -ret);
+		return SSL_CONNECTION_ERROR;
+	}
+	if((ret = mbedtls_ssl_set_hostname(&(tlsDataParams->ssl), pNetwork->tlsConnectParams.pDestinationURL)) != 0) {
+		IOT_ERROR(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
+		return SSL_CONNECTION_ERROR;
+	}
+	IOT_DEBUG("\n\nSSL state connect : %d ", tlsDataParams->ssl.state);
+	mbedtls_ssl_set_bio(&(tlsDataParams->ssl), &(tlsDataParams->server_fd), mbedtls_net_send, NULL,
+						mbedtls_net_recv_timeout);
+	IOT_DEBUG(" ok\n");
+
+	IOT_DEBUG("\n\nSSL state connect : %d ", tlsDataParams->ssl.state);
+	IOT_DEBUG("  . Performing the SSL/TLS handshake...");
+	while((ret = mbedtls_ssl_handshake(&(tlsDataParams->ssl))) != 0) {
+		if(ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {
+			IOT_ERROR(" failed\n  ! mbedtls_ssl_handshake returned -0x%x\n", -ret);
+			if(ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {
+				IOT_ERROR("    Unable to verify the server's certificate. "
+							  "Either it is invalid,\n"
+							  "    or you didn't set ca_file or ca_path "
+							  "to an appropriate value.\n"
+							  "    Alternatively, you may want to use "
+							  "auth_mode=optional for testing purposes.\n");
+			}
+			return SSL_CONNECTION_ERROR;
+		}
+	}
+
+	IOT_DEBUG(" ok\n    [ Protocol is %s ]\n    [ Ciphersuite is %s ]\n", mbedtls_ssl_get_version(&(tlsDataParams->ssl)),
+		  mbedtls_ssl_get_ciphersuite(&(tlsDataParams->ssl)));
+	if((ret = mbedtls_ssl_get_record_expansion(&(tlsDataParams->ssl))) >= 0) {
+		IOT_DEBUG("    [ Record expansion is %d ]\n", ret);
+	} else {
+		IOT_DEBUG("    [ Record expansion is unknown (compression) ]\n");
+	}
+
+	IOT_DEBUG("  . Verifying peer X.509 certificate...");
+
+	if(pNetwork->tlsConnectParams.ServerVerificationFlag == true) {
+		if((tlsDataParams->flags = mbedtls_ssl_get_verify_result(&(tlsDataParams->ssl))) != 0) {
+			char vrfy_buf[512];
+			IOT_ERROR(" failed\n");
+			mbedtls_x509_crt_verify_info(vrfy_buf, sizeof(vrfy_buf), "  ! ", tlsDataParams->flags);
+			IOT_ERROR("%s\n", vrfy_buf);
+			ret = SSL_CONNECTION_ERROR;
+		} else {
+			IOT_DEBUG(" ok\n");
+			ret = SUCCESS;
+		}
+	} else {
+		IOT_DEBUG(" Server Verification skipped\n");
+		ret = SUCCESS;
+	}
+
+#ifdef IOT_DEBUG
+	if (mbedtls_ssl_get_peer_cert(&(tlsDataParams->ssl)) != NULL) {
+		IOT_DEBUG("  . Peer certificate information    ...\n");
+		mbedtls_x509_crt_info((char *) buf, sizeof(buf) - 1, "      ", mbedtls_ssl_get_peer_cert(&(tlsDataParams->ssl)));
+		IOT_DEBUG("%s\n", buf);
+	}
+#endif
+
+	mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), IOT_SSL_READ_TIMEOUT);
+
+	return (IoT_Error_t) ret;
+}
+
+IoT_Error_t iot_tls_write(Network *pNetwork, unsigned char *pMsg, size_t len, Timer *timer, size_t *written_len) {
+	size_t written_so_far;
+	bool isErrorFlag = false;
+	int frags, ret;
+	TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);
+
+	for(written_so_far = 0, frags = 0;
+		written_so_far < len && !has_timer_expired(timer); written_so_far += ret, frags++) {
+		while(!has_timer_expired(timer) &&
+			  (ret = mbedtls_ssl_write(&(tlsDataParams->ssl), pMsg + written_so_far, len - written_so_far)) <= 0) {
+			if(ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {
+				IOT_ERROR(" failed\n  ! mbedtls_ssl_write returned -0x%x\n\n", -ret);
+				/* All other negative return values indicate connection needs to be reset.
+				* Will be caught in ping request so ignored here */
+				isErrorFlag = true;
+				break;
+			}
+		}
+		if(isErrorFlag) {
+			break;
+		}
+	}
+
+	*written_len = written_so_far;
+
+	if(isErrorFlag) {
+		return NETWORK_SSL_WRITE_ERROR;
+	} else if(has_timer_expired(timer) && written_so_far != len) {
+		return NETWORK_SSL_WRITE_TIMEOUT_ERROR;
+	}
+
+	return SUCCESS;
+}
+
+IoT_Error_t iot_tls_read(Network *pNetwork, unsigned char *pMsg, size_t len, Timer *timer, size_t *read_len) {
+	size_t rxLen = 0;
+	bool isErrorFlag = false;
+	bool isCompleteFlag = false;
+	uint32_t timerLeftVal = left_ms(timer);
+	TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);
+	int ret = 0;
+
+	do {
+		//mbedtls_ssl_conf_read_timeout(&(tlsDataParams->conf), timerLeftVal);
+		ret = mbedtls_ssl_read(&(tlsDataParams->ssl), pMsg, len);
+		if(ret >= 0) { /* 0 is for EOF */
+			rxLen += ret;
+		} else if(ret != MBEDTLS_ERR_SSL_WANT_READ) {
+			isErrorFlag = true;
+		}
+
+		/* All other negative return values indicate connection needs to be reset.
+		 * Will be caught in ping request so ignored here */
+
+		if(rxLen >= len) {
+			isCompleteFlag = true;
+		}
+		timerLeftVal = left_ms(timer);
+	} while(!isErrorFlag && !isCompleteFlag && timerLeftVal > 0);
+
+	*read_len = rxLen;
+
+	if(0 == rxLen && isErrorFlag) {
+		return NETWORK_SSL_NOTHING_TO_READ;
+	} else if(has_timer_expired(timer) && !isCompleteFlag) {
+		return NETWORK_SSL_READ_TIMEOUT_ERROR;
+	}
+
+	return SUCCESS;
+}
+
+IoT_Error_t iot_tls_disconnect(Network *pNetwork) {
+	mbedtls_ssl_context *ssl = &(pNetwork->tlsDataParams.ssl);
+	int ret = 0;
+	do {
+		ret = mbedtls_ssl_close_notify(ssl);
+	} while(ret == MBEDTLS_ERR_SSL_WANT_WRITE);
+
+	/* All other negative return values indicate connection needs to be reset.
+	 * No further action required since this is disconnect call */
+
+	return SUCCESS;
+}
+
+IoT_Error_t iot_tls_destroy(Network *pNetwork) {
+	TLSDataParams *tlsDataParams = &(pNetwork->tlsDataParams);
+
+	mbedtls_net_free(&(tlsDataParams->server_fd));
+
+	mbedtls_x509_crt_free(&(tlsDataParams->clicert));
+	mbedtls_x509_crt_free(&(tlsDataParams->cacert));
+	mbedtls_pk_free(&(tlsDataParams->pkey));
+	mbedtls_ssl_free(&(tlsDataParams->ssl));
+	mbedtls_ssl_config_free(&(tlsDataParams->conf));
+	mbedtls_ctr_drbg_free(&(tlsDataParams->ctr_drbg));
+	mbedtls_entropy_free(&(tlsDataParams->entropy));
+
+	return SUCCESS;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/platform/vxworks/mbedtls/network_platform.h b/platform/vxworks/mbedtls/network_platform.h
new file mode 100644
index 0000000..c2810a1
--- /dev/null
+++ b/platform/vxworks/mbedtls/network_platform.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+#ifndef IOTSDKC_NETWORK_MBEDTLS_PLATFORM_H_H
+
+#include "mbedtls/config.h"
+
+#include "mbedtls/platform.h"
+#include "mbedtls/net.h"
+#include "mbedtls/ssl.h"
+#include "mbedtls/entropy.h"
+#include "mbedtls/ctr_drbg.h"
+#include "mbedtls/certs.h"
+#include "mbedtls/x509.h"
+#include "mbedtls/error.h"
+#include "mbedtls/debug.h"
+#include "mbedtls/timing.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief TLS Connection Parameters
+ *
+ * Defines a type containing TLS specific parameters to be passed down to the
+ * TLS networking layer to create a TLS secured socket.
+ */
+typedef struct _TLSDataParams {
+	mbedtls_entropy_context entropy;
+	mbedtls_ctr_drbg_context ctr_drbg;
+	mbedtls_ssl_context ssl;
+	mbedtls_ssl_config conf;
+	uint32_t flags;
+	mbedtls_x509_crt cacert;
+	mbedtls_x509_crt clicert;
+	mbedtls_pk_context pkey;
+	mbedtls_net_context server_fd;
+}TLSDataParams;
+
+#define IOTSDKC_NETWORK_MBEDTLS_PLATFORM_H_H
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //IOTSDKC_NETWORK_MBEDTLS_PLATFORM_H_H
diff --git a/samples/vxworks/shadow_sample/Makefile b/samples/vxworks/shadow_sample/Makefile
new file mode 100644
index 0000000..20faf62
--- /dev/null
+++ b/samples/vxworks/shadow_sample/Makefile
@@ -0,0 +1,44 @@
+# Copyright (c) 2016, Wind River Systems, Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification, are
+# permitted provided that the following conditions are met:
+#
+# 1) Redistributions of source code must retain the above copyright notice,
+# this list of conditions and the following disclaimer.
+#
+# 2) Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation and/or
+# other materials provided with the distribution.
+#
+# 3) Neither the name of Wind River Systems nor the names of its contributors may be
+# used to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+EXE = shadow_sample.vxe
+
+EXTRA_DEFINE += -Dinit_timer=init_timer_wr
+
+ADDED_LIBS += -laws
+
+RTP_BASE_DIR = shadow_sample
+
+BUILD_ALL_OBJS = TRUE
+
+vpath %.c ../../../src
+
+OBJS = $(patsubst %.c,%.o,$(notdir $(wildcard ../../../src/*.c)))
+
+OBJS += shadow_sample.o
+
+include $(WIND_USR_MK)/rules.rtp.mk
diff --git a/samples/vxworks/shadow_sample/aws_iot_config.h b/samples/vxworks/shadow_sample/aws_iot_config.h
new file mode 100644
index 0000000..252c384
--- /dev/null
+++ b/samples/vxworks/shadow_sample/aws_iot_config.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file aws_iot_config.h
+ * @brief AWS IoT specific configuration file
+ */
+
+#ifndef SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+#define SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+
+// Get from console
+// =================================================
+#define AWS_IOT_MQTT_HOST              "" ///< Customer specific MQTT HOST. The same will be used for Thing Shadow
+#define AWS_IOT_MQTT_PORT              8883 ///< default port for MQTT/S
+#define AWS_IOT_MQTT_CLIENT_ID         "c-sdk-client-id" ///< MQTT client ID should be unique for every device
+#define AWS_IOT_MY_THING_NAME 		   "AWS-IoT-C-SDK" ///< Thing Name of the Shadow this device is associated with
+#define AWS_IOT_ROOT_CA_FILENAME       "rootCA.crt" ///< Root CA file name
+#define AWS_IOT_CERTIFICATE_FILENAME   "cert.pem" ///< device signed certificate file name
+#define AWS_IOT_PRIVATE_KEY_FILENAME   "privkey.pem" ///< Device private key filename
+// =================================================
+
+// MQTT PubSub
+#define AWS_IOT_MQTT_TX_BUF_LEN 512 ///< Any time a message is sent out through the MQTT layer. The message is copied into this buffer anytime a publish is done. This will also be used in the case of Thing Shadow
+#define AWS_IOT_MQTT_RX_BUF_LEN 512 ///< Any message that comes into the device should be less than this buffer size. If a received message is bigger than this buffer size the message will be dropped.
+#define AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS 5 ///< Maximum number of topic filters the MQTT client can handle at any given time. This should be increased appropriately when using Thing Shadow
+
+// Thing Shadow specific configs
+#define SHADOW_MAX_SIZE_OF_RX_BUFFER AWS_IOT_MQTT_RX_BUF_LEN+1 ///< Maximum size of the SHADOW buffer to store the received Shadow message
+#define MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES 80  ///< Maximum size of the Unique Client Id. For More info on the Client Id refer \ref response "Acknowledgments"
+#define MAX_SIZE_CLIENT_ID_WITH_SEQUENCE MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES + 10 ///< This is size of the extra sequence number that will be appended to the Unique client Id
+#define MAX_SIZE_CLIENT_TOKEN_CLIENT_SEQUENCE MAX_SIZE_CLIENT_ID_WITH_SEQUENCE + 20 ///< This is size of the the total clientToken key and value pair in the JSON
+#define MAX_ACKS_TO_COMEIN_AT_ANY_GIVEN_TIME 10 ///< At Any given time we will wait for this many responses. This will correlate to the rate at which the shadow actions are requested
+#define MAX_THINGNAME_HANDLED_AT_ANY_GIVEN_TIME 10 ///< We could perform shadow action on any thing Name and this is maximum Thing Names we can act on at any given time
+#define MAX_JSON_TOKEN_EXPECTED 120 ///< These are the max tokens that is expected to be in the Shadow JSON document. Include the metadata that gets published
+#define MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME 60 ///< All shadow actions have to be published or subscribed to a topic which is of the format $aws/things/{thingName}/shadow/update/accepted. This refers to the size of the topic without the Thing Name
+#define MAX_SIZE_OF_THING_NAME 20 ///< The Thing Name should not be bigger than this value. Modify this if the Thing Name needs to be bigger
+#define MAX_SHADOW_TOPIC_LENGTH_BYTES MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME + MAX_SIZE_OF_THING_NAME ///< This size includes the length of topic with Thing Name
+
+// Auto Reconnect specific config
+#define AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL 1000 ///< Minimum time before the First reconnect attempt is made as part of the exponential back-off algorithm
+#define AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL 128000 ///< Maximum time interval after which exponential back-off will stop attempting to reconnect.
+
+#endif /* SRC_SHADOW_IOT_SHADOW_CONFIG_H_ */
diff --git a/samples/vxworks/shadow_sample/shadow_sample.c b/samples/vxworks/shadow_sample/shadow_sample.c
new file mode 100644
index 0000000..efc5693
--- /dev/null
+++ b/samples/vxworks/shadow_sample/shadow_sample.c
@@ -0,0 +1,314 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file shadow_sample.c
+ * @brief A simple connected window example demonstrating the use of Thing Shadow
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+
+#include "aws_iot_config.h"
+#include "aws_iot_log.h"
+#include "aws_iot_version.h"
+#include "aws_iot_mqtt_client_interface.h"
+#include "aws_iot_shadow_interface.h"
+
+/*!
+ * The goal of this sample application is to demonstrate the capabilities of shadow.
+ * This device(say Connected Window) will open the window of a room based on temperature
+ * It can report to the Shadow the following parameters:
+ *  1. temperature of the room (double)
+ *  2. status of the window (open or close)
+ * It can act on commands from the cloud. In this case it will open or close the window based on the json object "windowOpen" data[open/close]
+ *
+ * The two variables from a device's perspective are double temperature and bool windowOpen
+ * The device needs to act on only on windowOpen variable, so we will create a primitiveJson_t object with callback
+ The Json Document in the cloud will be
+ {
+ "reported": {
+ "temperature": 0,
+ "windowOpen": false
+ },
+ "desired": {
+ "windowOpen": false
+ }
+ }
+ */
+
+#define ROOMTEMPERATURE_UPPERLIMIT 32.0f
+#define ROOMTEMPERATURE_LOWERLIMIT 25.0f
+#define STARTING_ROOMTEMPERATURE ROOMTEMPERATURE_LOWERLIMIT
+
+#define MAX_LENGTH_OF_UPDATE_JSON_BUFFER 200
+
+static char certDirectory[PATH_MAX + 1] = "";
+static char HostAddress[255] = AWS_IOT_MQTT_HOST;
+static uint32_t port = AWS_IOT_MQTT_PORT;
+static uint8_t numPubs = 5;
+
+static void simulateRoomTemperature(float *pRoomTemperature) {
+	static float deltaChange;
+
+	if(*pRoomTemperature >= ROOMTEMPERATURE_UPPERLIMIT) {
+		deltaChange = -0.5f;
+	} else if(*pRoomTemperature <= ROOMTEMPERATURE_LOWERLIMIT) {
+		deltaChange = 0.5f;
+	}
+
+	*pRoomTemperature += deltaChange;
+}
+
+void ShadowUpdateStatusCallback(const char *pThingName, ShadowActions_t action, Shadow_Ack_Status_t status,
+								const char *pReceivedJsonDocument, void *pContextData) {
+	IOT_UNUSED(pThingName);
+	IOT_UNUSED(action);
+	IOT_UNUSED(pReceivedJsonDocument);
+	IOT_UNUSED(pContextData);
+
+	if(SHADOW_ACK_TIMEOUT == status) {
+		IOT_INFO("Update Timeout--");
+	} else if(SHADOW_ACK_REJECTED == status) {
+		IOT_INFO("Update RejectedXX");
+	} else if(SHADOW_ACK_ACCEPTED == status) {
+		IOT_INFO("Update Accepted !!");
+	}
+}
+
+void windowActuate_Callback(const char *pJsonString, uint32_t JsonStringDataLen, jsonStruct_t *pContext) {
+	IOT_UNUSED(pJsonString);
+	IOT_UNUSED(JsonStringDataLen);
+
+	if(pContext != NULL) {
+		IOT_INFO("Delta - Window state changed to %d", *(bool *) (pContext->pData));
+	}
+}
+
+void parseInputArgsForConnectParams(int argc, char **argv) {
+	int opt;
+
+	while(-1 != (opt = getopt(argc, argv, "h:p:c:n:"))) {
+		switch(opt) {
+			case 'h':
+				strcpy(HostAddress, optarg);
+				IOT_DEBUG("Host %s", optarg);
+				break;
+			case 'p':
+				port = atoi(optarg);
+				IOT_DEBUG("arg %s", optarg);
+				break;
+			case 'c':
+				strcpy(certDirectory, optarg);
+				IOT_DEBUG("cert root directory %s", optarg);
+				break;
+			case 'n':
+				numPubs = atoi(optarg);
+				IOT_DEBUG("num pubs %s", optarg);
+				break;
+			case '?':
+				if(optopt == 'c') {
+					IOT_ERROR("Option -%c requires an argument.", optopt);
+				} else if(isprint(optopt)) {
+					IOT_WARN("Unknown option `-%c'.", optopt);
+				} else {
+					IOT_WARN("Unknown option character `\\x%x'.", optopt);
+				}
+				break;
+			default:
+				IOT_ERROR("ERROR in command line argument parsing");
+				break;
+		}
+	}
+
+}
+
+int usrSetSysTime(void)
+    {
+    struct tm tms;
+    struct timeval tval;
+
+    if (gettimeofday(&tval, NULL) == 0)
+        {
+        tms = *localtime((time_t *)&tval.tv_sec);
+        if (tms.tm_year < 116)
+            {
+            printf("Warning! System clock is %s", ctime ((time_t *)&tval.tv_sec));
+
+            /* Set time to AUG 1, 2016 */
+
+            tms.tm_year  = 116;
+            tms.tm_mon   = 7;
+            tms.tm_mday  = 1;
+            tval.tv_sec  = mktime(&tms);
+            tval.tv_usec = 0;
+
+            if (settimeofday(&tval, NULL) == 0)
+                {
+                printf("Stepping clock to %s", ctime ((time_t *)&tval.tv_sec));
+                return 0;
+                }
+            else
+                {
+                printf("Could not step clock, please set correct system time. Exiting.");
+                return -1;
+                }
+            }
+
+        return 0;
+        }
+
+    return -1;
+    }
+
+int main(int argc, char **argv) {
+	IoT_Error_t rc = FAILURE;
+	int32_t i = 0;
+
+	char JsonDocumentBuffer[MAX_LENGTH_OF_UPDATE_JSON_BUFFER];
+	size_t sizeOfJsonDocumentBuffer = sizeof(JsonDocumentBuffer) / sizeof(JsonDocumentBuffer[0]);
+	char *pJsonStringToUpdate;
+	float temperature = 0.0;
+
+	bool windowOpen = false;
+	jsonStruct_t windowActuator;
+	windowActuator.cb = windowActuate_Callback;
+	windowActuator.pData = &windowOpen;
+	windowActuator.pKey = "windowOpen";
+	windowActuator.type = SHADOW_JSON_BOOL;
+
+	jsonStruct_t temperatureHandler;
+	temperatureHandler.cb = NULL;
+	temperatureHandler.pKey = "temperature";
+	temperatureHandler.pData = &temperature;
+	temperatureHandler.type = SHADOW_JSON_FLOAT;
+
+	char rootCA[PATH_MAX + 1];
+	char clientCRT[PATH_MAX + 1];
+	char clientKey[PATH_MAX + 1];
+	char CurrentWD[PATH_MAX + 1];
+
+	IOT_INFO("\nAWS IoT SDK Version %d.%d.%d-%s\n", VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH, VERSION_TAG);
+
+    chdir("/romfs");
+	getcwd(CurrentWD, sizeof(CurrentWD));
+	snprintf(rootCA, PATH_MAX + 1, "%s/%s", CurrentWD, AWS_IOT_ROOT_CA_FILENAME);
+	snprintf(clientCRT, PATH_MAX + 1, "%s/%s", CurrentWD, AWS_IOT_CERTIFICATE_FILENAME);
+	snprintf(clientKey, PATH_MAX + 1, "%s/%s", CurrentWD, AWS_IOT_PRIVATE_KEY_FILENAME);
+
+	IOT_DEBUG("rootCA %s", rootCA);
+	IOT_DEBUG("clientCRT %s", clientCRT);
+	IOT_DEBUG("clientKey %s", clientKey);
+
+    if(usrSetSysTime() != 0)
+        return;
+
+    parseInputArgsForConnectParams(argc, argv);
+
+	// initialize the mqtt client
+	AWS_IoT_Client mqttClient;
+
+	ShadowInitParameters_t sp = ShadowInitParametersDefault;
+	sp.pHost = AWS_IOT_MQTT_HOST;
+	sp.port = AWS_IOT_MQTT_PORT;
+	sp.pClientCRT = clientCRT;
+	sp.pClientKey = clientKey;
+	sp.pRootCA = rootCA;
+	sp.enableAutoReconnect = false;
+	sp.disconnectHandler = NULL;
+
+	IOT_INFO("Shadow Init");
+	rc = aws_iot_shadow_init(&mqttClient, &sp);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Shadow Connection Error");
+		return rc;
+	}
+
+	ShadowConnectParameters_t scp = ShadowConnectParametersDefault;
+	scp.pMyThingName = AWS_IOT_MY_THING_NAME;
+	scp.pMqttClientId = AWS_IOT_MQTT_CLIENT_ID;
+	scp.mqttClientIdLen = (uint16_t) strlen(AWS_IOT_MQTT_CLIENT_ID);
+
+	IOT_INFO("Shadow Connect");
+	rc = aws_iot_shadow_connect(&mqttClient, &scp);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Shadow Connection Error");
+		return rc;
+	}
+
+	/*
+	 * Enable Auto Reconnect functionality. Minimum and Maximum time of Exponential backoff are set in aws_iot_config.h
+	 *  #AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL
+	 *  #AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL
+	 */
+	rc = aws_iot_shadow_set_autoreconnect_status(&mqttClient, true);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Unable to set Auto Reconnect to true - %d", rc);
+		return rc;
+	}
+
+	rc = aws_iot_shadow_register_delta(&mqttClient, &windowActuator);
+
+	if(SUCCESS != rc) {
+		IOT_ERROR("Shadow Register Delta Error");
+	}
+	temperature = STARTING_ROOMTEMPERATURE;
+
+	// loop and publish a change in temperature
+	while(NETWORK_ATTEMPTING_RECONNECT == rc || NETWORK_RECONNECTED == rc || SUCCESS == rc) {
+		rc = aws_iot_shadow_yield(&mqttClient, 200);
+		if(NETWORK_ATTEMPTING_RECONNECT == rc) {
+			sleep(1);
+			// If the client is attempting to reconnect we will skip the rest of the loop.
+			continue;
+		}
+		IOT_INFO("\n=======================================================================================\n");
+		IOT_INFO("On Device: window state %s", windowOpen ? "true" : "false");
+		simulateRoomTemperature(&temperature);
+
+		rc = aws_iot_shadow_init_json_document(JsonDocumentBuffer, sizeOfJsonDocumentBuffer);
+		if(SUCCESS == rc) {
+			rc = aws_iot_shadow_add_reported(JsonDocumentBuffer, sizeOfJsonDocumentBuffer, 2, &temperatureHandler,
+											 &windowActuator);
+			if(SUCCESS == rc) {
+				rc = aws_iot_finalize_json_document(JsonDocumentBuffer, sizeOfJsonDocumentBuffer);
+				if(SUCCESS == rc) {
+					IOT_INFO("Update Shadow: %s", JsonDocumentBuffer);
+					rc = aws_iot_shadow_update(&mqttClient, AWS_IOT_MY_THING_NAME, JsonDocumentBuffer,
+											   ShadowUpdateStatusCallback, NULL, 4, true);
+				}
+			}
+		}
+		IOT_INFO("*****************************************************************************************\n");
+		sleep(1);
+	}
+
+	if(SUCCESS != rc) {
+		IOT_ERROR("An error occurred in the loop %d", rc);
+	}
+
+	IOT_INFO("Disconnecting");
+	rc = aws_iot_shadow_disconnect(&mqttClient);
+
+	if(SUCCESS != rc) {
+		IOT_ERROR("Disconnect error %d", rc);
+	}
+
+	return rc;
+}
diff --git a/samples/vxworks/subscribe_publish_sample/Makefile b/samples/vxworks/subscribe_publish_sample/Makefile
new file mode 100644
index 0000000..867472f
--- /dev/null
+++ b/samples/vxworks/subscribe_publish_sample/Makefile
@@ -0,0 +1,44 @@
+# Copyright (c) 2016, Wind River Systems, Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification, are
+# permitted provided that the following conditions are met:
+#
+# 1) Redistributions of source code must retain the above copyright notice,
+# this list of conditions and the following disclaimer.
+#
+# 2) Redistributions in binary form must reproduce the above copyright notice,
+# this list of conditions and the following disclaimer in the documentation and/or
+# other materials provided with the distribution.
+#
+# 3) Neither the name of Wind River Systems nor the names of its contributors may be
+# used to endorse or promote products derived from this software without specific
+# prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+EXE = subscribe_publish_sample.vxe
+
+EXTRA_DEFINE += -Dinit_timer=init_timer_wr
+
+ADDED_LIBS += -laws
+
+RTP_BASE_DIR = subscribe_publish_sample
+
+BUILD_ALL_OBJS = TRUE
+
+vpath %.c ../../../src
+
+OBJS = $(patsubst %.c,%.o,$(notdir $(wildcard ../../../src/*.c)))
+
+OBJS += subscribe_publish_sample.o
+
+include $(WIND_USR_MK)/rules.rtp.mk
diff --git a/samples/vxworks/subscribe_publish_sample/aws_iot_config.h b/samples/vxworks/subscribe_publish_sample/aws_iot_config.h
new file mode 100644
index 0000000..252c384
--- /dev/null
+++ b/samples/vxworks/subscribe_publish_sample/aws_iot_config.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file aws_iot_config.h
+ * @brief AWS IoT specific configuration file
+ */
+
+#ifndef SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+#define SRC_SHADOW_IOT_SHADOW_CONFIG_H_
+
+// Get from console
+// =================================================
+#define AWS_IOT_MQTT_HOST              "" ///< Customer specific MQTT HOST. The same will be used for Thing Shadow
+#define AWS_IOT_MQTT_PORT              8883 ///< default port for MQTT/S
+#define AWS_IOT_MQTT_CLIENT_ID         "c-sdk-client-id" ///< MQTT client ID should be unique for every device
+#define AWS_IOT_MY_THING_NAME 		   "AWS-IoT-C-SDK" ///< Thing Name of the Shadow this device is associated with
+#define AWS_IOT_ROOT_CA_FILENAME       "rootCA.crt" ///< Root CA file name
+#define AWS_IOT_CERTIFICATE_FILENAME   "cert.pem" ///< device signed certificate file name
+#define AWS_IOT_PRIVATE_KEY_FILENAME   "privkey.pem" ///< Device private key filename
+// =================================================
+
+// MQTT PubSub
+#define AWS_IOT_MQTT_TX_BUF_LEN 512 ///< Any time a message is sent out through the MQTT layer. The message is copied into this buffer anytime a publish is done. This will also be used in the case of Thing Shadow
+#define AWS_IOT_MQTT_RX_BUF_LEN 512 ///< Any message that comes into the device should be less than this buffer size. If a received message is bigger than this buffer size the message will be dropped.
+#define AWS_IOT_MQTT_NUM_SUBSCRIBE_HANDLERS 5 ///< Maximum number of topic filters the MQTT client can handle at any given time. This should be increased appropriately when using Thing Shadow
+
+// Thing Shadow specific configs
+#define SHADOW_MAX_SIZE_OF_RX_BUFFER AWS_IOT_MQTT_RX_BUF_LEN+1 ///< Maximum size of the SHADOW buffer to store the received Shadow message
+#define MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES 80  ///< Maximum size of the Unique Client Id. For More info on the Client Id refer \ref response "Acknowledgments"
+#define MAX_SIZE_CLIENT_ID_WITH_SEQUENCE MAX_SIZE_OF_UNIQUE_CLIENT_ID_BYTES + 10 ///< This is size of the extra sequence number that will be appended to the Unique client Id
+#define MAX_SIZE_CLIENT_TOKEN_CLIENT_SEQUENCE MAX_SIZE_CLIENT_ID_WITH_SEQUENCE + 20 ///< This is size of the the total clientToken key and value pair in the JSON
+#define MAX_ACKS_TO_COMEIN_AT_ANY_GIVEN_TIME 10 ///< At Any given time we will wait for this many responses. This will correlate to the rate at which the shadow actions are requested
+#define MAX_THINGNAME_HANDLED_AT_ANY_GIVEN_TIME 10 ///< We could perform shadow action on any thing Name and this is maximum Thing Names we can act on at any given time
+#define MAX_JSON_TOKEN_EXPECTED 120 ///< These are the max tokens that is expected to be in the Shadow JSON document. Include the metadata that gets published
+#define MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME 60 ///< All shadow actions have to be published or subscribed to a topic which is of the format $aws/things/{thingName}/shadow/update/accepted. This refers to the size of the topic without the Thing Name
+#define MAX_SIZE_OF_THING_NAME 20 ///< The Thing Name should not be bigger than this value. Modify this if the Thing Name needs to be bigger
+#define MAX_SHADOW_TOPIC_LENGTH_BYTES MAX_SHADOW_TOPIC_LENGTH_WITHOUT_THINGNAME + MAX_SIZE_OF_THING_NAME ///< This size includes the length of topic with Thing Name
+
+// Auto Reconnect specific config
+#define AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL 1000 ///< Minimum time before the First reconnect attempt is made as part of the exponential back-off algorithm
+#define AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL 128000 ///< Maximum time interval after which exponential back-off will stop attempting to reconnect.
+
+#endif /* SRC_SHADOW_IOT_SHADOW_CONFIG_H_ */
diff --git a/samples/vxworks/subscribe_publish_sample/subscribe_publish_sample.c b/samples/vxworks/subscribe_publish_sample/subscribe_publish_sample.c
new file mode 100644
index 0000000..6a7913f
--- /dev/null
+++ b/samples/vxworks/subscribe_publish_sample/subscribe_publish_sample.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "license" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+/**
+ * @file subscribe_publish_sample.c
+ * @brief simple MQTT publish and subscribe on the same topic
+ *
+ * This example takes the parameters from the aws_iot_config.h file and establishes a connection to the AWS IoT MQTT Platform.
+ * It subscribes and publishes to the same topic - "sdkTest/sub"
+ *
+ * If all the certs are correct, you should see the messages received by the application in a loop.
+ *
+ * The application takes in the certificate path, host name , port and the number of times the publish should happen.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <limits.h>
+#include <string.h>
+#include <vxWorks.h>
+
+#include "aws_iot_config.h"
+#include "aws_iot_log.h"
+#include "aws_iot_version.h"
+#include "aws_iot_mqtt_client_interface.h"
+
+/**
+ * @brief Default cert location
+ */
+char certDirectory[PATH_MAX + 1] = "";
+
+/**
+ * @brief Default MQTT HOST URL is pulled from the aws_iot_config.h
+ */
+char HostAddress[255] = AWS_IOT_MQTT_HOST;
+
+/**
+ * @brief Default MQTT port is pulled from the aws_iot_config.h
+ */
+uint32_t port = AWS_IOT_MQTT_PORT;
+
+/**
+ * @brief This parameter will avoid infinite loop of publish and exit the program after certain number of publishes
+ */
+uint32_t publishCount = 0;
+
+void iot_subscribe_callback_handler(AWS_IoT_Client *pClient, char *topicName, uint16_t topicNameLen,
+									IoT_Publish_Message_Params *params, void *pData) {
+	IOT_UNUSED(pData);
+	IOT_UNUSED(pClient);
+	IOT_INFO("Subscribe callback");
+	IOT_INFO("%.*s\t%.*s", topicNameLen, topicName, (int) params->payloadLen, params->payload);
+}
+
+void disconnectCallbackHandler(AWS_IoT_Client *pClient, void *data) {
+	IOT_WARN("MQTT Disconnect");
+	IoT_Error_t rc = FAILURE;
+
+	if(NULL == pClient) {
+		return;
+	}
+
+	IOT_UNUSED(data);
+
+	if(aws_iot_is_autoreconnect_enabled(pClient)) {
+		IOT_INFO("Auto Reconnect is enabled, Reconnecting attempt will start now");
+	} else {
+		IOT_WARN("Auto Reconnect not enabled. Starting manual reconnect...");
+		rc = aws_iot_mqtt_attempt_reconnect(pClient);
+		if(NETWORK_RECONNECTED == rc) {
+			IOT_WARN("Manual Reconnect Successful");
+		} else {
+			IOT_WARN("Manual Reconnect Failed - %d", rc);
+		}
+	}
+}
+
+void parseInputArgsForConnectParams(int argc, char **argv) {
+	int opt;
+
+	while(-1 != (opt = getopt(argc, argv, "h:p:c:x:"))) {
+		switch(opt) {
+			case 'h':
+				strcpy(HostAddress, optarg);
+				IOT_DEBUG("Host %s", optarg);
+				break;
+			case 'p':
+				port = atoi(optarg);
+				IOT_DEBUG("arg %s", optarg);
+				break;
+			case 'c':
+				strcpy(certDirectory, optarg);
+				IOT_DEBUG("cert root directory %s", optarg);
+				break;
+			case 'x':
+				publishCount = atoi(optarg);
+				IOT_DEBUG("publish %s times\n", optarg);
+				break;
+			case '?':
+				if(optopt == 'c') {
+					IOT_ERROR("Option -%c requires an argument.", optopt);
+				} else if(isprint(optopt)) {
+					IOT_WARN("Unknown option `-%c'.", optopt);
+				} else {
+					IOT_WARN("Unknown option character `\\x%x'.", optopt);
+				}
+				break;
+			default:
+				IOT_ERROR("Error in command line argument parsing");
+				break;
+		}
+	}
+
+}
+
+int usrSetSysTime(void)
+    {
+    struct tm tms;
+    struct timeval tval;
+
+    if (gettimeofday(&tval, NULL) == 0)
+        {
+        tms = *localtime((time_t *)&tval.tv_sec);
+        if (tms.tm_year < 116)
+            {
+            printf("Warning! System clock is %s", ctime ((time_t *)&tval.tv_sec));
+
+            /* Set time to AUG 1, 2016 */
+
+            tms.tm_year  = 116;
+            tms.tm_mon   = 7;
+            tms.tm_mday  = 1;
+            tval.tv_sec  = mktime(&tms);
+            tval.tv_usec = 0;
+
+            if (settimeofday(&tval, NULL) == 0)
+                {
+                printf("Stepping clock to %s", ctime ((time_t *)&tval.tv_sec));
+                return 0;
+                }
+            else
+                {
+                printf("Could not step clock, please set correct system time. Exiting.");
+                return -1;
+                }
+            }
+
+        return 0;
+        }
+
+    return -1;
+    }
+
+int main(int argc, char **argv) {
+	bool infinitePublishFlag = true;
+
+	char rootCA[PATH_MAX + 1];
+	char clientCRT[PATH_MAX + 1];
+	char clientKey[PATH_MAX + 1];
+	char CurrentWD[PATH_MAX + 1];
+	char cPayload[100];
+
+	int32_t i = 0;
+
+	IoT_Error_t rc = FAILURE;
+
+	AWS_IoT_Client client;
+	IoT_Client_Init_Params mqttInitParams = iotClientInitParamsDefault;
+	IoT_Client_Connect_Params connectParams = iotClientConnectParamsDefault;
+
+	IoT_Publish_Message_Params paramsQOS0;
+	IoT_Publish_Message_Params paramsQOS1;
+
+    if(usrSetSysTime() != 0)
+        return;
+
+	parseInputArgsForConnectParams(argc, argv);
+
+	IOT_INFO("\nAWS IoT SDK Version %d.%d.%d-%s\n", VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH, VERSION_TAG);
+
+    chdir("/romfs");
+	getcwd(CurrentWD, sizeof(CurrentWD));
+
+    snprintf(rootCA, PATH_MAX + 1, "%s/%s", CurrentWD, AWS_IOT_ROOT_CA_FILENAME);
+	snprintf(clientCRT, PATH_MAX + 1, "%s/%s", CurrentWD, AWS_IOT_CERTIFICATE_FILENAME);
+	snprintf(clientKey, PATH_MAX + 1, "%s/%s", CurrentWD, AWS_IOT_PRIVATE_KEY_FILENAME);
+
+	IOT_DEBUG("rootCA %s", rootCA);
+	IOT_DEBUG("clientCRT %s", clientCRT);
+	IOT_DEBUG("clientKey %s", clientKey);
+	mqttInitParams.enableAutoReconnect = false; // We enable this later below
+	mqttInitParams.pHostURL = HostAddress;
+	mqttInitParams.port = port;
+	mqttInitParams.pRootCALocation = rootCA;
+	mqttInitParams.pDeviceCertLocation = clientCRT;
+	mqttInitParams.pDevicePrivateKeyLocation = clientKey;
+	mqttInitParams.mqttCommandTimeout_ms = 20000;
+	mqttInitParams.tlsHandshakeTimeout_ms = 5000;
+	mqttInitParams.isSSLHostnameVerify = true;
+	mqttInitParams.disconnectHandler = disconnectCallbackHandler;
+	mqttInitParams.disconnectHandlerData = NULL;
+
+	rc = aws_iot_mqtt_init(&client, &mqttInitParams);
+	if(SUCCESS != rc) {
+		IOT_ERROR("aws_iot_mqtt_init returned error : %d ", rc);
+		return rc;
+	}
+
+	connectParams.keepAliveIntervalInSec = 10;
+	connectParams.isCleanSession = true;
+	connectParams.MQTTVersion = MQTT_3_1_1;
+	connectParams.pClientID = AWS_IOT_MQTT_CLIENT_ID;
+	connectParams.clientIDLen = (uint16_t) strlen(AWS_IOT_MQTT_CLIENT_ID);
+	connectParams.isWillMsgPresent = false;
+
+	IOT_INFO("Connecting...");
+	rc = aws_iot_mqtt_connect(&client, &connectParams);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Error(%d) connecting to %s:%d", rc, mqttInitParams.pHostURL, mqttInitParams.port);
+		return rc;
+	}
+
+	/*
+	 * Enable Auto Reconnect functionality. Minimum and Maximum time of Exponential backoff are set in aws_iot_config.h
+	 *  #AWS_IOT_MQTT_MIN_RECONNECT_WAIT_INTERVAL
+	 *  #AWS_IOT_MQTT_MAX_RECONNECT_WAIT_INTERVAL
+	 */
+	rc = aws_iot_mqtt_autoreconnect_set_status(&client, true);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Unable to set Auto Reconnect to true - %d", rc);
+		return rc;
+	}
+
+	IOT_INFO("Subscribing...");
+	rc = aws_iot_mqtt_subscribe(&client, "sdkTest/sub", 11, QOS0, iot_subscribe_callback_handler, NULL);
+	if(SUCCESS != rc) {
+		IOT_ERROR("Error subscribing : %d ", rc);
+		return rc;
+	}
+
+	sprintf(cPayload, "%s : %d ", "hello from SDK", i);
+
+	paramsQOS0.qos = QOS0;
+	paramsQOS0.payload = (void *) cPayload;
+	paramsQOS0.isRetained = 0;
+
+	paramsQOS1.qos = QOS1;
+	paramsQOS1.payload = (void *) cPayload;
+	paramsQOS1.isRetained = 0;
+
+	if(publishCount != 0) {
+		infinitePublishFlag = false;
+	}
+
+	while((NETWORK_ATTEMPTING_RECONNECT == rc || NETWORK_RECONNECTED == rc || SUCCESS == rc)
+		  && (publishCount > 0 || infinitePublishFlag)) {
+
+		//Max time the yield function will wait for read messages
+		rc = aws_iot_mqtt_yield(&client, 100);
+		if(NETWORK_ATTEMPTING_RECONNECT == rc) {
+			// If the client is attempting to reconnect we will skip the rest of the loop.
+			continue;
+		}
+
+		IOT_INFO("-->sleep");
+		sleep(1);
+		sprintf(cPayload, "%s : %d ", "hello from SDK QOS0", i++);
+		paramsQOS0.payloadLen = strlen(cPayload);
+		rc = aws_iot_mqtt_publish(&client, "sdkTest/sub", 11, &paramsQOS0);
+		if(publishCount > 0) {
+			publishCount--;
+		}
+
+		sprintf(cPayload, "%s : %d ", "hello from SDK QOS1", i++);
+		paramsQOS1.payloadLen = strlen(cPayload);
+		do {
+			rc = aws_iot_mqtt_publish(&client, "sdkTest/sub", 11, &paramsQOS1);
+			if(publishCount > 0) {
+				publishCount--;
+			}
+		} while(MQTT_REQUEST_TIMEOUT_ERROR == rc && (publishCount > 0 || infinitePublishFlag));
+	}
+
+	if(SUCCESS != rc) {
+		IOT_ERROR("An error occurred in the loop.\n");
+	} else {
+		IOT_INFO("Publish done\n");
+	}
+
+	return rc;
+}
